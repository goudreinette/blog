<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Writing a Lisp</title>
    <meta name="description" content="I've been working on my first general purpose programming language last week, guided by the books SICP and Write Yourself a Scheme in 48 Hours.  This has been a goal of mine for a long time, but it somehow always looked intimidating. I was glad to find ou...">
    <meta name="author"      content="Rein van der Woerd">
    <meta name="keywords"    content="Lisp">
    <meta name="viewport"    content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon.png">
    <link rel="canonical" href="http://www.reinvanderwoerd.nl/blog/2017/03/18/writing-a-lisp/">

    <link rel="prev" href="/blog/2017/03/23/adt-s-in-clojure/">
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/css/pygments.css">
    <link rel="stylesheet" type="text/css" href="/css/scribble.css">
    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <!-- Feeds -->
    <link rel="alternate" type="application/atom+xml"
          href="/feeds/all.atom.xml" title="Atom Feed">
    <link rel="alternate" type="application/rss+xml"
          href="/feeds/all.rss.xml" title="RSS Feed">
    <!-- JS -->
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-94082535-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>
  <body>
    <!-- A standard Twitter Bootstrap nav bar -->
    <header class="navbar navbar-default"
            role="banner">
      <div class="container">
        <div class="navbar-header">
          <!--<button type="button"
                  class="navbar-toggle"
                  data-toggle="collapse"
                  data-target=".our-nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>-->
          <a href="/index.html" class="navbar-brand">REIN VAN DER WOERD</a>
        </div>
        <div class="navbar"
             role="navigation">
          <ul class="nav navbar-nav">

            <!--<li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                Tags <b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="/index.html">All Posts</a></li>

<li><a href="/tags/Clojure.html">Clojure</a></li>

<li><a href="/tags/Lisp.html">Lisp</a></li>
              </ul>
            </li>-->
            <li>
              <a href="/index.html">Blog</a>
            </li> 
            <li>
              <a href="/About.html">About</a>
            </li> 
          </ul>
        </div>
      </div>
    </header>
    <div class="container">
      <div class="row">
        <!-- Main column -->
        <div id="content" class="col-md-12">

          <article>
  <header>
    <h1>Writing a Lisp</h1>
    <p class='date-and-tags'>
    <time datetime="2017-03-18" pubdate="true">2017-03-18</time>, in <span class="tags"><a href="/tags/Lisp.html">Lisp</a></span></p>
  </header>

<p>I&rsquo;ve been working on my first general purpose programming language last week, guided by the books SICP and Write Yourself a Scheme in 48 Hours.  This has been a goal of mine for a long time, but it somehow always looked intimidating. I was glad to find out that interpreters can actually be astonishingly simple, and would like to share what I learned along the way.</p>
<!-- more-->

<p>This code is based on Write Yourself a Scheme. If you&rsquo;d like to see the code in context, you can follow along <a href="https://github.com/reinvdwoerd/lisp">here</a>.</p>

<h2 id="implementing-macros">Implementing macro&rsquo;s</h2>

<p>Since macro&rsquo;s are just functions of <code>code -&gt; code</code>, adding a simple macro system to my Lisp was fairly easy.  First, I added an additional field to my function record to identify macro&rsquo;s.</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">data</span> <span class="kt">LispVal</span> <span class="ow">=</span>  <span class="o">...</span>  
                <span class="o">|</span> <span class="kt">Func</span> <span class="p">{</span> <span class="n">isMacro</span> <span class="ow">::</span> <span class="kt">Bool</span><span class="p">,</span> <span class="c1">-- new</span>
                         <span class="n">params</span>  <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">],</span>
                         <span class="n">body</span>    <span class="ow">::</span> <span class="p">[</span><span class="kt">LispVal</span><span class="p">],</span>
                         <span class="n">closure</span> <span class="ow">::</span> <span class="kt">Env</span> <span class="p">}</span>
</pre></div>

</div>

<p>Next, I wrote a new evaluation rule for macro definitions.</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">makeFn</span> <span class="n">isMacro</span> <span class="n">params</span> <span class="n">body</span> <span class="n">env</span> <span class="ow">=</span>
  <span class="c1">--</span>

<span class="nf">makeMacro</span> <span class="ow">=</span> <span class="n">makeFn</span> <span class="kt">True</span>

<span class="nf">eval</span> <span class="n">env</span> <span class="p">(</span><span class="kt">List</span> <span class="p">(</span><span class="kt">Symbol</span> <span class="s">"define-syntax"</span> <span class="kt">:</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">Symbol</span> <span class="n">var</span> <span class="kt">:</span> <span class="n">params</span><span class="p">)</span> <span class="kt">:</span> <span class="n">body</span><span class="p">))</span> <span class="ow">=</span>
  <span class="n">makeMacro</span> <span class="n">params</span> <span class="n">body</span> <span class="n">env</span> <span class="o">&gt;&gt;=</span> <span class="n">defineVar</span> <span class="n">env</span> <span class="n">var</span>
</pre></div>

</div>

<p>Finally, I changed the way macro invocations are evaluated, by passing arguments to the macro unevaluated, and evaluating the result instead.</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">eval</span> <span class="n">env</span> <span class="p">(</span><span class="kt">List</span> <span class="p">(</span><span class="n">func</span> <span class="kt">:</span> <span class="n">args</span><span class="p">))</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">evaluatedFunc</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">env</span> <span class="n">func</span> <span class="c1">-- required to determine evaluation order</span>
  <span class="kr">case</span> <span class="n">evaluatedFunc</span> <span class="kr">of</span>
    <span class="kt">Func</span> <span class="p">{</span><span class="n">isMacro</span> <span class="ow">=</span> <span class="kt">True</span><span class="p">}</span> <span class="ow">-&gt;</span>
      <span class="n">apply</span> <span class="n">evaluatedFunc</span> <span class="n">args</span> <span class="o">&gt;&gt;=</span> <span class="n">eval</span> <span class="n">env</span> <span class="c1">-- evaluate results</span>

    <span class="kr">_</span> <span class="ow">-&gt;</span>
      <span class="n">evalMany</span> <span class="n">env</span> <span class="n">args</span> <span class="o">&gt;&gt;=</span> <span class="n">apply</span> <span class="n">evaluatedFunc</span> <span class="c1">-- evaluate arguments</span>
</pre></div>

</div>

<p>To make macro&rsquo;s more easy to use, I added syntax and evaluation rules for quote/unquote.</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">quote</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">char</span> <span class="sc">&#39;</span><span class="se">\&#39;</span><span class="sc">&#39;</span>
  <span class="n">form</span> <span class="ow">&lt;-</span> <span class="n">expr</span>
  <span class="n">return</span> <span class="o">$</span> <span class="kt">List</span> <span class="p">[</span><span class="kt">Symbol</span> <span class="s">"quote"</span><span class="p">,</span> <span class="n">form</span><span class="p">]</span>

<span class="nf">unquote</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">char</span> <span class="sc">&#39;~&#39;</span>
  <span class="n">form</span> <span class="ow">&lt;-</span> <span class="n">expr</span>
  <span class="n">return</span> <span class="o">$</span> <span class="kt">List</span> <span class="p">[</span><span class="kt">Symbol</span> <span class="s">"unquote"</span><span class="p">,</span> <span class="n">form</span><span class="p">]</span>

<span class="nf">expr</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">expr</span> <span class="ow">=</span> <span class="o">...</span> <span class="o">&lt;|&gt;</span> <span class="n">quote</span> <span class="o">&lt;|&gt;</span> <span class="n">unquote</span>
</pre></div>

</div>

<p>Quoted expressions are walked, and any unquoted expression within is replaced by it&rsquo;s evaluated result.</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">eval</span> <span class="n">env</span> <span class="p">(</span><span class="kt">List</span> <span class="p">[</span><span class="kt">Symbol</span> <span class="s">"quote"</span><span class="p">,</span> <span class="n">form</span><span class="p">])</span> <span class="ow">=</span> <span class="kr">do</span> 
  <span class="n">evalUnquotes</span> <span class="n">form</span>
  <span class="kr">where</span> <span class="n">evalUnquotes</span> <span class="n">form</span> <span class="ow">=</span>
          <span class="kr">case</span> <span class="n">form</span> <span class="kr">of</span>
            <span class="kt">List</span> <span class="p">[</span><span class="kt">Symbol</span> <span class="s">"unquote"</span><span class="p">,</span> <span class="n">form</span><span class="p">]</span> <span class="ow">-&gt;</span>
              <span class="n">eval</span> <span class="n">env</span> <span class="n">form</span>
            <span class="kt">List</span> <span class="n">items</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
              <span class="n">results</span> <span class="ow">&lt;-</span> <span class="n">traverse</span> <span class="n">evalUnquotes</span> <span class="n">items</span>
              <span class="n">return</span> <span class="o">$</span> <span class="kt">List</span> <span class="n">results</span>
            <span class="kr">_</span> <span class="ow">-&gt;</span>
              <span class="n">return</span> <span class="n">form</span>
</pre></div>

</div>

<p>After this, you should have a fully functional macro system, and additional syntax like the following can be defined from within the language:</p>

<div class="brush: scheme">
 <div class="source">
  <pre><span></span><span class="p">(</span><span class="k">define-syntax </span><span class="p">(</span><span class="nf">unless</span> <span class="nv">test</span> <span class="nv">then</span><span class="p">)</span>
  <span class="o">&#39;</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">~test</span><span class="p">)</span>
     <span class="nv">~then</span>
      <span class="nv">nil</span><span class="p">))</span>
</pre></div>

</div>

<h2 id="varargs-and-special-forms">Varargs and special forms</h2>

<p>The combination of macro&rsquo;s and varargs allowed me to define some additional special forms from within the language.</p>

<h4 id="let">let</h4>

<p>Let can be derived from lambda, binding arguments to parameters and creating a new local enviroment.</p>

<div class="brush: scheme">
 <div class="source">
  <pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">binding-vars</span> <span class="nv">bindings</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">map </span><span class="nv">first</span> <span class="p">(</span><span class="nf">pairs</span> <span class="nv">bindings</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">binding-vals</span> <span class="nv">bindings</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">map </span><span class="nv">second</span> <span class="p">(</span><span class="nf">pairs</span> <span class="nv">bindings</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="p">(</span><span class="k">let </span><span class="nv">bindings</span> <span class="o">.</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">list*</span> <span class="p">(</span><span class="nf">list*</span> <span class="ss">&#39;lambda</span>  <span class="p">(</span><span class="nf">binding-vars</span> <span class="nv">bindings</span><span class="p">)</span> <span class="nv">body</span><span class="p">)</span> 
         <span class="p">(</span><span class="nf">binding-vals</span> <span class="nv">bindings</span><span class="p">))))</span>

<span class="p">(</span><span class="k">let </span><span class="p">(</span><span class="nf">x</span> <span class="mi">10</span>
      <span class="nv">y</span> <span class="mi">3</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="c1">;=&gt; 30</span>
</pre></div>

</div>

<h4 id="cond">cond</h4>

<p>What&rsquo;s interesting about this special form is that both it and &lsquo;if&rsquo; can be defined in terms of each other. Since Write Yourself a Scheme decided to make &lsquo;if&rsquo; the primitive form, I wrote cond to expand to nested if&rsquo;s.</p>

<div class="brush: scheme">
 <div class="source">
  <pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">wrap-if</span> <span class="nv">acc</span> <span class="nv">clause</span><span class="p">)</span>
  <span class="o">&#39;</span><span class="p">(</span><span class="k">if </span><span class="nv">~</span><span class="p">(</span><span class="nf">first</span> <span class="nv">clause</span><span class="p">)</span>
     <span class="nv">~</span><span class="p">(</span><span class="nf">second</span> <span class="nv">clause</span><span class="p">)</span>
     <span class="nv">~acc</span><span class="p">))</span>

<span class="p">(</span><span class="k">define-syntax </span><span class="p">(</span><span class="k">cond </span><span class="o">.</span> <span class="nv">clauses</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">reduce</span> <span class="nv">wrap-if</span> <span class="ss">&#39;nil</span> <span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nf">pairs</span> <span class="nv">clauses</span><span class="p">))))</span>


<span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">5</span><span class="p">)</span>

<span class="p">(</span><span class="nf">cond</span>
  <span class="p">(</span><span class="nb">symbol? </span><span class="nv">x</span><span class="p">)</span> <span class="s">"symbol"</span>
  <span class="p">(</span><span class="nb">number? </span><span class="nv">x</span><span class="p">)</span> <span class="s">"number"</span>
  <span class="ss">&#39;else</span>       <span class="s">"something else"</span><span class="p">)</span> <span class="c1">;=&gt; "number"</span>
</pre></div>

</div>

<h4 id="dobegin">do/begin</h4>

<p>Evaluates it&rsquo;s arguments left to right, and returns the last result. Since this is already the default evaluation order, all I needed to do was to return the last result.</p>

<div class="brush: scheme">
 <div class="source">
  <pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="k">do </span><span class="o">.</span> <span class="nv">forms</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">last</span> <span class="nv">forms</span><span class="p">))</span>

<span class="p">(</span><span class="k">do </span>
  <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">empty?</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span> <span class="c1">;=&gt; false</span>
</pre></div>

</div>

<h2 id="require">Require</h2>

<p>Require is still implemented at the language level. I might switch to a macro later.</p>

<p>It works by evaluating all expressions in the file, collecting the results and returning them as a list. I found this behaviour useful in the Repl to discover imported identifiers.</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">eval</span> <span class="n">env</span> <span class="p">(</span><span class="kt">List</span> <span class="p">[</span><span class="kt">Symbol</span> <span class="s">"require"</span><span class="p">,</span> <span class="kt">Symbol</span> <span class="n">filepath</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
      <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">liftIO</span> <span class="o">$</span> <span class="n">readFile</span> <span class="p">(</span><span class="n">filepath</span> <span class="o">++</span> <span class="s">".lisp"</span><span class="p">)</span>
      <span class="n">forms</span> <span class="ow">&lt;-</span> <span class="n">parseFile</span> <span class="n">contents</span>
      <span class="n">results</span> <span class="ow">&lt;-</span> <span class="n">traverse</span> <span class="p">(</span><span class="n">eval</span> <span class="n">env</span><span class="p">)</span> <span class="n">forms</span>
      <span class="n">return</span> <span class="o">$</span> <span class="kt">List</span> <span class="n">result</span>
</pre></div>

</div>

<pre><code>lisp=&gt; (require lisp/core)
(a inc compose flip second last list pair ...)</code></pre>

<h2 id="enviroment-inspection">Enviroment inspection</h2>

<p>I made the current lexical enviroment accessible using <code>(env)</code>. A useful feauture to have when debugging.</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="c1">-- Env.hs</span>
<span class="nf">getVars</span> <span class="ow">::</span> <span class="kt">Env</span> <span class="ow">-&gt;</span> <span class="kt">IOThrowsError</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">LispVal</span><span class="p">)]</span>
<span class="nf">getVars</span> <span class="n">envRef</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">env</span> <span class="ow">&lt;-</span> <span class="n">liftIO</span> <span class="o">$</span> <span class="n">readIORef</span> <span class="n">envRef</span>
  <span class="kr">let</span> <span class="n">vars</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">fst</span> <span class="n">env</span>
  <span class="n">vals</span> <span class="ow">&lt;-</span> <span class="n">traverse</span> <span class="p">(</span><span class="n">getVar</span> <span class="n">envRef</span><span class="p">)</span> <span class="n">vars</span>
  <span class="n">return</span> <span class="o">$</span> <span class="n">zip</span> <span class="n">vars</span> <span class="n">vals</span>


<span class="c1">-- Eval.hs</span>
<span class="nf">eval</span> <span class="n">env</span> <span class="p">(</span><span class="kt">List</span> <span class="p">[</span><span class="kt">Symbol</span> <span class="s">"env"</span><span class="p">])</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">vars</span> <span class="ow">&lt;-</span> <span class="n">getVars</span> <span class="n">env</span>
  <span class="n">return</span> <span class="o">$</span> <span class="kt">List</span> <span class="o">$</span> <span class="n">map</span> <span class="n">toPair</span> <span class="n">vars</span>
  <span class="kr">where</span> <span class="n">toPair</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="p">[</span><span class="kt">Symbol</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">])</span>
</pre></div>

</div>

<pre><code>lisp=&gt; (env)
((+ &lt;primitive function&gt;) (a 10) ...)</code></pre>

<h2 id="repl">Repl</h2>

<p>During development I used the convenient <code>rlwrap</code> to improve repl usability. I later replaced it with Haskeline. Any thrown errors are printed red.</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">import</span>           <span class="nn">System.Console.ANSI</span>
<span class="kr">import</span>           <span class="nn">System.Console.Haskeline</span>

<span class="nf">repl</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">globalEnv</span> <span class="ow">&lt;-</span> <span class="n">newEnv</span>
  <span class="n">runInputT</span> <span class="n">defaultSettings</span> <span class="o">$</span> <span class="n">loop</span> <span class="n">globalEnv</span>

<span class="nf">loop</span> <span class="n">env</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">line</span> <span class="ow">&lt;-</span> <span class="n">getInputLine</span> <span class="s">"lisp=&gt; "</span>
  <span class="kr">case</span> <span class="n">line</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span>
    <span class="kt">Just</span> <span class="n">expr</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
      <span class="n">evaled</span> <span class="ow">&lt;-</span> <span class="n">liftIO</span> <span class="o">$</span> <span class="n">evalString</span> <span class="n">env</span> <span class="n">expr</span>
      <span class="n">liftIO</span> <span class="o">$</span> <span class="n">either</span> <span class="n">printError</span> <span class="n">print</span> <span class="n">evaled</span>
      <span class="n">loop</span> <span class="n">env</span>

<span class="nf">evalString</span> <span class="ow">::</span> <span class="kt">Env</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Either</span> <span class="kt">LispError</span> <span class="kt">LispVal</span><span class="p">)</span>
<span class="nf">evalString</span> <span class="n">env</span> <span class="n">expr</span> <span class="ow">=</span>
  <span class="n">runExceptT</span> <span class="p">(</span><span class="n">parseLine</span> <span class="n">expr</span> <span class="o">&gt;&gt;=</span> <span class="n">eval</span> <span class="n">env</span><span class="p">)</span>

<span class="nf">printError</span> <span class="n">err</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">setSGR</span> <span class="p">[</span><span class="kt">SetColor</span> <span class="kt">Foreground</span> <span class="kt">Vivid</span> <span class="kt">Red</span><span class="p">]</span>
  <span class="n">print</span> <span class="n">err</span>
  <span class="n">setSGR</span> <span class="p">[</span><span class="kt">Reset</span><span class="p">]</span>
</pre></div>

</div>

<h2 id="conclusion">Conclusion</h2>

<p>I hope you found this writeup useful. Any suggestions for improvements are very much appreciated!</p>
  <footer class="post-footer">
    <script type="text/javascript">
      !function(d,s,id){
          var js,fjs=d.getElementsByTagName(s)[0];
          if(!d.getElementById(id)){
              js=d.createElement(s);
              js.id=id;
              js.src="//platform.twitter.com/widgets.js";
              fjs.parentNode.insertBefore(js,fjs);
          }
      }(document,"script","twitter-wjs");
    </script>
    <a href="https://twitter.com/share"
       class="twitter-share-button"
       data-url="http://www.reinvanderwoerd.nl/blog/2017/03/18/writing-a-lisp/"
       data-dnt="true">
      "Tweet"</a>
    <script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script>
    <g:plusone size="medium" href="http://www.reinvanderwoerd.nl/blog/2017/03/18/writing-a-lisp/"></g:plusone>
    <script type="text/javascript">
      var disqus_shortname = 'shortname';
      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript';
          dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <div id="disqus_thread"></div>
    <ul class="pager">
    <li class="previous">
      <a href="/blog/2017/03/23/adt-s-in-clojure/">&larr; <em>ADT&rsquo;s in Clojure</em></a>
    </li>

    </ul>
  </footer>
</article>
        </div>
      </div>
      <footer>
        <hr />
        <!--<p>Site generated
        by <a href="https://github.com/greghendershott/frog">Frog</a>,
        the <strong>fr</strong>ozen bl<strong>og</strong> tool.</p>-->
        <p style="float: right">
          <a href="/feeds/all.atom.xml">Atom</a> -
          <a href="/feeds/all.rss.xml">RSS</a>
        </p>
      </footer>
    </div>
    <!-- </body> JS -->
    <script type="text/javascript" src="//code.jquery.com/jquery.min.js"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  </body>
</html>